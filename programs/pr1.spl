//This is how you write a comment in our language

/*
This is how you write a multiline comment in our language. For each of our programs
we will present our solution without any comments for your clarity followed
by an annotated version of the solution where we will explain what is going on in more detail
*/

while(!streams[0].empty){

    print(streams[0].take, streams[0].take, streams[1].take);

};

end;


/*

We took inspiration from both Haskell and Java in the syntax, liking
the readability of haskell with minimal brackets but also clear
seperation of expressions using semicolons and also using curly braces 
as opposed to eg "then" or "else" in our if statements

while(!streams[0].empty){

    print $ streams[0].take, streams[0].take, streams[1].take;

};

end;

We have tried to make the syntax similar to Java as we find it to be more
readable and clear than e.g. "method arg1, arg2" for the iterative style we have chosen.
We could have omitted "()" at the end of keywords however we think it helps
to clearly distinguish variables from keyword "methods" and find it to be more
readable and clear writing keyword "methods" this way as opposed to Haskell like "method arg1, arg2" 
for the iterative style we have chosen

The streams can be treated as if there is one big array of streams ready to be manipulated which
is indeed the case as our haskell code scans the input text file of stream data into a list of lists
which can be accessed using this syntax. streams[n].empty() returns true if stream n is empty,
streams[n].drop() drops the head from stream n and updates state accordingly, streams[n].take() also
drops the head but it returns the value of the removed head too

It is important to note that streams[n].take() is an int expression so it cannot be used as a standalone 
expression by itself, it must be used somewhere where an int expression is expected eg below you can see
two examples; string = IntExp, and printAll(IntExp, IntExp, IntExp ...)

while(!streams[0].empty() && !streams[1].empty()){

     
    This is a more verbose albeit possibly more clear solution

    a = streams[0].take();
    b = streams[0].take();
    c = streams[1].take();

    print and printAll are the only two keyword "methods" which take arguments, whereas
    streams are treated as if they are "objects" in java and methods are called "on" them
    using streams[n].method()

    printAll(a, b, c);
    

    //This is a shorter solution
    printAll(streams[0].take(), streams[0].take(), streams[1].take());

};


The end keyword is not strictly necessary per se, the evaluator method will also stop
when it runs out of sub expressions to evaluate so excluding "end" here is also a 
perfectly valid solution; however, we would like to encourage it to be convention when
using our language to always make use of "end" as that way it is more clear when looking at
the program where it ends evaluation and also means you have the option to end the
program somewhere in the middle of the code e.g. if you are checking for some end condition in
a loop and do not need to carry on evaluating the program then you can simply use the end keyword

end();

*/